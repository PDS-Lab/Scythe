#ifndef BENCHMARK_BENCHMARK_RANDOMER_H
#define BENCHMARK_BENCHMARK_RANDOMER_H

#include <limits>
#include <random>
#include <algorithm>
#include <vector>


namespace benchmark {

template<class IntType = uint64_t, class RealType = double>
class zipf_table_distribution
{
   public:
      typedef IntType result_type;

      static_assert(std::numeric_limits<IntType>::is_integer, "");
      static_assert(!std::numeric_limits<RealType>::is_integer, "");

      /// zipf_table_distribution(N, s)
      /// Zipf distribution for `N` items, in the range `[1,N]` inclusive.
      /// The distribution follows the power-law 1/n^s with exponent `s`.
      /// This uses a table-lookup, and thus provides values more
      /// quickly than zipf_distribution. However, the table can take
      /// up a considerable amount of RAM, and initializing this table
      /// can consume significant time.
      zipf_table_distribution(const IntType n,
                              const RealType q=1.0) :
         _n(init(n,q)),
         _q(q),
         _dist(_pdf.begin(), _pdf.end())
      {}
      void reset() {}

      IntType operator()(std::mt19937_64& rng)
      {
         return _dist(rng);
      }

      /// Returns the parameter the distribution was constructed with.
      RealType s() const { return _q; }
      /// Returns the minimum value potentially generated by the distribution.
      result_type min() const { return 1; }
      /// Returns the maximum value potentially generated by the distribution.
      result_type max() const { return _n; }

   private:
      std::vector<RealType>               _pdf;  ///< Prob. distribution
      IntType                             _n;    ///< Number of elements
      RealType                            _q;    ///< Exponent
      std::discrete_distribution<IntType> _dist; ///< Draw generator

      /** Initialize the probability mass function */
      IntType init(const IntType n, const RealType q)
      {
         _pdf.reserve(n+1);
         _pdf.emplace_back(0.0);
         for (IntType i=1; i<=n; i++)
            _pdf.emplace_back(std::pow((double) i, -q));
         return n;
      }
};

class FastRandom {
 public:
  FastRandom(unsigned long sed)
      : seed(0) {
    SetSeed0(sed);
  }

  FastRandom() : seed(0) {
    SetSeed0(seed);
  }

  inline unsigned long
  Next() {
    return ((unsigned long)Next(32) << 32) + Next(32);
  }

  inline uint32_t
  NextU32() {
    return Next(32);
  }

  inline uint16_t
  NextU16() {
    return Next(16);
  }

  /** [0.0, 1.0) */
  inline double
  NextUniform() {
    return (((unsigned long)Next(26) << 27) + Next(27)) / (double)(1L << 53);
  }

  inline char
  NextChar() {
    return Next(8) % 256;
  }

  inline std::string
  NextString(size_t len) {
    std::string s(len, 0);
    for (size_t i = 0; i < len; i++)
      s[i] = NextChar();
    return s;
  }

  inline unsigned long
  GetSeed() {
    return seed;
  }

  inline void
  SetSeed(unsigned long sed) {
    this->seed = sed;
  }

  inline void
  SetSeed0(unsigned long sed) {
    this->seed = (sed ^ 0x5DEECE66DL) & ((1L << 48) - 1);
  }

  inline uint64_t RandNumber(int min, int max) {
    return CheckBetweenInclusive((uint64_t)(NextUniform() * (max - min + 1) + min), min, max);
  }

  inline uint64_t CheckBetweenInclusive(uint64_t v, uint64_t min, uint64_t max) {
    assert(v >= min);
    assert(v <= max);
    return v;
  }

 private:
  inline unsigned long
  Next(unsigned int bits) {
    seed = (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1);
    return (unsigned long)(seed >> (48 - bits));
  }

  unsigned long seed;
};


}

#endif